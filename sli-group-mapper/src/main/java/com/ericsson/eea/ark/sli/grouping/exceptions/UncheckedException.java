/*******************************************************************************
 * Copyright (c) 2015 Ericsson, Inc. All Rights Reserved.
 *
 * LICENSED MATERIAL - PROPERTY OF ERICSSON
 * Possession and/or use of this material is subject to the provisions
 * of a written license agreement with Ericsson
 *
 * ERICSSON CONFIDENTIAL - RESTRICTED ACCESS
 * This document and the confidential information it contains shall
 * be distributed, routed or made available solely to authorized persons
 * having a need to know within Ericsson, except with written
 * permission of Ericsson.
 *
 *******************************************************************************/

package com.ericsson.eea.ark.sli.grouping.exceptions;


import java.io.PrintStream;
import java.io.PrintWriter;


/**
 * This is the base class for all the Application related fatal exceptions. It
 * inherits from RuntimeException and therefore as an unchecked exception. It
 * implements the logic necessary for wrapping a given Throwable object. This is
 * useful for catch clauses that throws a different exception than the one that
 * was catched, without loosing the original exception's information. In
 * particular, the stack trace information is not lost.
 */
public class UncheckedException extends RuntimeException implements ThrowableIFC {

   /** . */
   private static final long serialVersionUID = 1L;

   /**
    * Holds the message received by the constructor, or the resulting message
    * generated by <code>getMessage</code>.
    */
   protected String          msg;

   /**
    * Flag indicating if <code>msg_</code> is holding the resulting message
    * generated by <code>getMessage</code>.
    */
   protected boolean         cachedMsg;

   /**
    * This attribute references to an exception, in case the constructed object
    * is wrapping another exception.
    */
   protected Throwable       exception;

   /**
    * Attribute holding a buffer to be pre-appended to the Exception's message.
    */
   protected StringBuffer    msgBuffer;


   /** Constructs the exception object with the specified message. */
   public UncheckedException(String message) {

      msg = message;
   }


   /** Constructs the exception object, by wrapping the specified exception. */
   public UncheckedException(Throwable ex) {

      exception = ex;
   }


   /**
    * Constructs the exception object, by wrapping the specified exception and
    * also setting the specified message.
    */
   public UncheckedException(Throwable ex, String message) {

      msg = message;
      exception = ex;
   }


   /** Returns the wrapped exception. */
   public Throwable getException() {

      return exception;
   }


   /** Appends the specified message to the UncheckedException's error message. */
   public ThrowableIFC append(String m) {

      if (msgBuffer == null) {

         // Transfer msg contents to buffer. -----------------------------------
         if (msg != null) {

            getBuffer().append(msg).append("\n");
            msg = null;
         }
      }

      // Append message. -------------------------------------------------------
      getBuffer().append(m).append("\n");

      return this;
   }


   /**
    * Pre-appends the specified message to the UncheckedException's error
    * message.
    */
   public ThrowableIFC prepend(String m) {

      // Prepend the received message using a temporary buffer. ----------------
      StringBuffer tmpBuffer = new StringBuffer(); // StringBufferPool.get();

      tmpBuffer.append(m).append("\n");

      if (msgBuffer == null) {
         // Transfer msg contents to buffer. -----------------------------------
         if (msg != null) {
            tmpBuffer.append(msg).append("\n");
            msg = null;
         }
      }
      else {
         // Transfer old buffer contents to buffer. ----------------------------
         tmpBuffer.append(msgBuffer.toString()).append("\n");

         // StringBufferPool.recycle(msgBuffer);
         msgBuffer = tmpBuffer;
      }

      return this;
   }


   /**
    * Returns the contained message string. If we contain an exception and our
    * message string is not empty, return our message string, which is a
    * combination of both messages.
    */
   public String getMessage() {

      // Return the cached message derived previously --------------------------
      if (cachedMsg) { return msg; }

      // If append or prepend were never called, append msg to buffer. ---------
      if (msg != null && msg.length() > 0) {
         getBuffer().append(msg).append("\n");
      }

      // Get msg from parent. --------------------------------------------------
      msg = super.getMessage();
      if (msg != null && msg.length() > 0) {
         getBuffer().append(msg).append("\n");
      }

      // Get message from wrapped exception. -----------------------------------
      if (exception != null) {
         msg = exception.getMessage();
         if (msg != null && msg.length() > 0) {
            getBuffer().append(msg).append("\n");
         }
      }

      // Cache the resulting message for posterior usage. ----------------------
      if (msgBuffer != null) {
         cachedMsg = true;
         msg = msgBuffer.toString();

         // Recycle the no longer needed StringBuffer. -------------------------
         // StringBufferPool.recycle(msgBuffer);
         msgBuffer = null;
      }

      return msg;
   }


   /** Prints the stack trace to the standard output. */
   public void printStackTrace() {

      if (exception == null) {
         super.printStackTrace();
      }
      else {
         exception.printStackTrace();
      }
   }


   /** Prints the stack trace to the specified PrintStream. */
   public void printStackTrace(PrintStream ps) {

      if (exception == null) {
         super.printStackTrace(ps);
      }
      else {
         exception.printStackTrace(ps);
      }
   }


   /** Prints the stack trace to the specified PrintWriter. */
   public void printStackTrace(PrintWriter pw) {

      if (exception == null) {
         super.printStackTrace(pw);
      }
      else {
         exception.printStackTrace(pw);
      }
   }


   /** Indicates if one of the wrapped exceptions is instance of this class. */
   public boolean isCauseOf(ThrowableIFC excpt) {

      boolean rc = false;
      for (Object obj = excpt; !rc && obj != null && obj instanceof UncheckedException; obj = ((UncheckedException) obj).exception) {
         rc = obj instanceof UncheckedException;
      }
      return rc;
   }


   /** Indicates if one of the wrapped exceptions is instance of this class. */
   protected StringBuffer getBuffer() {

      return (msgBuffer != null) ? msgBuffer : (msgBuffer = new StringBuffer());
   }


   // /** Rethrows the exception as the received exception class.*/
   // public static void rethrow(ArgumentsException obj) throws ArgumentsException {
   //
   // if (this instanceof ArgumentsException)
   //    throw (ArgumentsException) obj;
   // else
   //    throw new ArgumentsException("Cannot convert " + obj.getClass().getName() +" into an ArgumentsException");
   // }
}
